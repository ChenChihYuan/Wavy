import*as THREE from"three";var definitions_perlin='#define GLSLIFY 1\n// From https://github.com/hughsk/glsl-noise/blob/master/periodic/2d.glsl\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin(vec2 P) {\n\n  vec2 rep = vec2(255.0, 255.0);\n\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n\n  vec4 norm = taylorInvSqrt(\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return map(2.3 * n_xy, -1.0, 1.0, 0.0, 1.0);\n}\n\nfloat fbm(vec2 pos, vec4 props) {\n  float persistance = props.x;\n  float lacunarity = props.y;\n  float redistribution = props.z;\n  int octaves = int(props.w);\n\n  float result = 0.0;\n  float amplitude = 1.0;\n  float frequency = 1.0;\n  float maximum = amplitude;\n\n  for (int i = 0; i < 2; i++) {\n\n    vec2 p = pos.xy * frequency;\n\n    float noiseVal = perlin(p);\n    result += noiseVal * amplitude;\n\n    frequency *= lacunarity;\n    amplitude *= persistance;\n    maximum += amplitude;\n  }\n\n  float redistributed = pow(result, redistribution);\n  return redistributed / maximum;\n}\n',p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];class Perlin{constructor(e){const t=[new THREE.Vector3(1,1,0),new THREE.Vector3(-1,1,0),new THREE.Vector3(1,-1,0),new THREE.Vector3(-1,-1,0),new THREE.Vector3(1,0,1),new THREE.Vector3(-1,0,1),new THREE.Vector3(1,0,-1),new THREE.Vector3(-1,0,-1),new THREE.Vector3(0,1,1),new THREE.Vector3(0,-1,1),new THREE.Vector3(0,1,-1),new THREE.Vector3(0,-1,-1)];var n=new Array(512),r=new Array(512);e||(e=1),e*=65536,(e=Math.floor(e))<256&&(e|=e<<8);for(var i=0;i<256;i++){var o;o=1&i?p[i]^255&e:p[i]^e>>8&255,n[i]=n[i+256]=o,r[i]=r[i+256]=t[o%12]}this._seed=e,this._offsetMatrix=[new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,1),new THREE.Vector3(0,1,0),new THREE.Vector3(0,1,1),new THREE.Vector3(1,0,0),new THREE.Vector3(1,0,1),new THREE.Vector3(1,1,0),new THREE.Vector3(1,1,1)],this.shaderChunk={defines:"",header:definitions_perlin,main:"",uniforms:[{three_noise_seed:this._seed}]},this.perm=n,this.gradP=r}_fade(e){return e*e*e*(e*(6*e-15)+10)}_lerp(e,t,n){return(1-n)*e+n*t}_gradient(e){return e instanceof THREE.Vector3?e.x+this.perm[e.y+this.perm[e.z]]:e.x+this.perm[e.y]}static map(e,t,n,r,i){return(e-t)*(i-r)/(n-t)+r}get2(e){void 0!==e.z&&(e=new THREE.Vector2(e.x,e.y));const t=new THREE.Vector2(Math.floor(e.x),Math.floor(e.y));e.sub(t),t.x&=255,t.y&=255;const n=[];for(let r=0;r<4;r++){const i=this._offsetMatrix[2*r],o=new THREE.Vector2(i.x,i.y),s=this.gradP[this._gradient((new THREE.Vector2).addVectors(t,o))],a=new THREE.Vector2(s.x,s.y),c=(new THREE.Vector2).subVectors(e,o);n.push(a.dot(c))}const r=this._fade(e.x),i=this._fade(e.y);return this._lerp(this._lerp(n[0],n[2],r),this._lerp(n[1],n[3],r),i)}get3(e){if(void 0===e.z)throw"Input to Perlin::get3() must be of type THREE.Vector3";const t=new THREE.Vector3(Math.floor(e.x),Math.floor(e.y),Math.floor(e.z));e.sub(t),t.x&=255,t.y&=255,t.z&=255;const n=[];for(let r=0;r<8;r++){const i=this._offsetMatrix[r],o=this.gradP[this._gradient((new THREE.Vector3).addVectors(t,i))],s=(new THREE.Vector3).subVectors(e,i);n.push(o.dot(s))}const r=this._fade(e.x),i=this._fade(e.y),o=this._fade(e.z);return this._lerp(this._lerp(this._lerp(n[0],n[4],r),this._lerp(n[1],n[5],r),o),this._lerp(this._lerp(n[2],n[6],r),this._lerp(n[3],n[7],r),o),i)}}class FBM{constructor(e){const{seed:t,scale:n,persistance:r,lacunarity:i,octaves:o,redistribution:s}=e;this._noise=new Perlin(t),this._scale=n||1,this._persistance=r||.5,this._lacunarity=i||2,this._octaves=o||6,this._redistribution=s||1}get2(e){let t=0,n=1,r=1,i=n,o=this._noise.get2.bind(this._noise);for(let s=0;s<this._octaves;s++)t+=o(new THREE.Vector2(e.x*this._scale*r,e.y*this._scale*r))*n,r*=this._lacunarity,n*=this._persistance,i+=n;return Math.pow(t,this._redistribution)/i}get3(e){let t=0,n=1,r=1,i=n,o=this._noise.get3.bind(this._noise);for(let s=0;s<this._octaves;s++)t+=o(new THREE.Vector3(e.x*this._scale*r,e.y*this._scale*r,e.z*this._scale*r))*n,r*=this._lacunarity,n*=this._persistance,i+=n;return Math.pow(t,this._redistribution)/i}}export{FBM,Perlin};